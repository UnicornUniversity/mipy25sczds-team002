Index: src/game/game_state.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport random\r\nimport math\r\nfrom entities.player import Player\r\nfrom entities.zombies import Zombie, ToughZombie\r\nfrom entities.items import Item, HealthPack, Weapon, Powerup\r\nfrom game.map_generator import MapGenerator\r\nfrom systems.effects import MuzzleFlash, BulletImpact, BloodSplatter\r\nfrom utils.constants import (\r\n    WINDOW_WIDTH, WINDOW_HEIGHT, TILE_SIZE,\r\n    CAMERA_LERP, BLACK, WHITE, MAP_WIDTH, MAP_HEIGHT,\r\n    DEBUG_FONT_SIZE, DEBUG_TEXT_COLOR,\r\n    PLAYER_MAX_HEALTH, PICKUP_NOTIFICATION_DURATION\r\n)\r\n\r\n\r\nclass GameState:\r\n    \"\"\"Base class for game states\"\"\"\r\n\r\n    def handle_event(self, event):\r\n        \"\"\"Event processing\"\"\"\r\n        pass\r\n\r\n    def update(self, dt):\r\n        \"\"\"State update\"\"\"\r\n        pass\r\n\r\n    def render(self, screen, fps=0):\r\n        \"\"\"State rendering\"\"\"\r\n        pass\r\n\r\n\r\nclass MenuState(GameState):\r\n    \"\"\"Main menu\"\"\"\r\n\r\n    def __init__(self):\r\n        self.font = pygame.font.Font(None, 74)\r\n        self.title_text = self.font.render(\"DEADLOCK\", True, (255, 255, 255))\r\n        self.subtitle_font = pygame.font.Font(None, 36)\r\n        self.subtitle_text = self.subtitle_font.render(\"Press SPACE to start\", True, (200, 200, 200))\r\n\r\n    def handle_event(self, event):\r\n        if event.type == pygame.KEYDOWN:\r\n            if event.key == pygame.K_SPACE:\r\n                # PÅ™epnout na gameplay\r\n                return \"gameplay\"\r\n        return None\r\n\r\n    def render(self, screen, fps=0):\r\n        screen_rect = screen.get_rect()\r\n        title_rect = self.title_text.get_rect(center=(screen_rect.centerx, screen_rect.centery - 50))\r\n        subtitle_rect = self.subtitle_text.get_rect(center=(screen_rect.centerx, screen_rect.centery + 50))\r\n\r\n        screen.blit(self.title_text, title_rect)\r\n        screen.blit(self.subtitle_text, subtitle_rect)\r\n\r\n\r\nclass GameplayState(GameState):\r\n    \"\"\"Main gameplay state\"\"\"\r\n\r\n    # Class variable to store the current instance\r\n    instance = None\r\n\r\n    def __init__(self):\r\n        # Set the instance to self\r\n        GameplayState.instance = self\r\n\r\n        # Create the map generator\r\n        self.map_generator = MapGenerator()\r\n\r\n        # Find a walkable tile near the center for the player\r\n        center_x = (TILE_SIZE * MAP_WIDTH) // 2\r\n        center_y = (TILE_SIZE * MAP_HEIGHT) // 2\r\n\r\n        # Search for a walkable tile in a spiral pattern around the center\r\n        player_x, player_y = self._find_walkable_position(center_x, center_y)\r\n        self.player = Player(player_x, player_y)\r\n\r\n        # Camera position (top-left corner of the view)\r\n        self.camera_x = 0\r\n        self.camera_y = 0\r\n\r\n        # Create a list to store zombies\r\n        self.zombies = []\r\n\r\n        # Create three test zombies at random positions away from the player\r\n        for _ in range(3):\r\n            self._spawn_zombie()\r\n\r\n        # Create a list to store items\r\n        self.items = []\r\n\r\n        # Spawn random weapons around the map\r\n        self._spawn_random_weapons(5)  # Spawn 5 random weapons\r\n\r\n        # Create a list to store bullets\r\n        self.bullets = []\r\n\r\n        # Pickup notification\r\n        self.pickup_message = \"\"\r\n        self.pickup_timer = 0\r\n\r\n        # Mouse button state tracking\r\n        self.left_mouse_down = False\r\n\r\n        # Debug mode (toggled with F1)\r\n        self.debug_mode = False\r\n        self.debug_font = pygame.font.Font(None, DEBUG_FONT_SIZE)\r\n\r\n        # Visual effects\r\n        self.effects = []\r\n\r\n    def _find_walkable_position(self, center_x, center_y):\r\n        \"\"\"Find a walkable position near the specified center coordinates\"\"\"\r\n        # Start at the center\r\n        x, y = center_x, center_y\r\n\r\n        # If the center is walkable, return it\r\n        if self.map_generator.is_walkable(x, y):\r\n            return x, y\r\n\r\n        # Search in a spiral pattern\r\n        for radius in range(1, 100):  # Limit search radius to avoid infinite loop\r\n            # Check positions in a square around the center\r\n            for dx in range(-radius, radius + 1):\r\n                for dy in range(-radius, radius + 1):\r\n                    # Skip positions that aren't on the edge of the square\r\n                    if abs(dx) != radius and abs(dy) != radius:\r\n                        continue\r\n\r\n                    # Calculate position\r\n                    pos_x = center_x + dx * TILE_SIZE\r\n                    pos_y = center_y + dy * TILE_SIZE\r\n\r\n                    # Check if position is walkable\r\n                    if self.map_generator.is_walkable(pos_x, pos_y):\r\n                        return pos_x, pos_y\r\n\r\n        # If no walkable position found, return the center anyway\r\n        return center_x, center_y\r\n\r\n    def _spawn_zombie(self):\r\n        \"\"\"Spawn a zombie at a random position away from the player on a walkable tile\"\"\"\r\n        # Choose a random position at least 200 pixels away from the player\r\n        while True:\r\n            x = random.randint(0, TILE_SIZE * MAP_WIDTH)\r\n            y = random.randint(0, TILE_SIZE * MAP_HEIGHT)\r\n\r\n            # Calculate distance to player\r\n            dx = x - self.player.x\r\n            dy = y - self.player.y\r\n            distance = (dx * dx + dy * dy) ** 0.5\r\n\r\n            # If far enough away and on a walkable tile, create the zombie\r\n            if distance > 200 and self.map_generator.is_walkable(x, y):\r\n                # 20% chance to spawn a tough zombie\r\n                if random.random() < 0.2:\r\n                    self.zombies.append(ToughZombie(x, y))\r\n                else:\r\n                    self.zombies.append(Zombie(x, y))\r\n                break\r\n\r\n    def _spawn_random_weapons(self, count=5):\r\n        \"\"\"Spawn random weapons around the map\r\n\r\n        Args:\r\n            count (int): Number of weapons to spawn\r\n        \"\"\"\r\n        # Spawn the specified number of weapons\r\n        for _ in range(count):\r\n            # Find a random walkable position on the map\r\n            self._spawn_random_item()\r\n\r\n    def _spawn_random_item(self, near_player=False, weapon_type=None):\r\n        \"\"\"Spawn a random item at a random position on the map\r\n\r\n        Args:\r\n            near_player (bool): Whether to spawn the item near the player\r\n            weapon_type (str, optional): Specific weapon type to spawn\r\n\r\n        Returns:\r\n            Item: The spawned item, or None if no suitable position was found\r\n        \"\"\"\r\n        if near_player:\r\n            # Find a position within 10 tiles of the player\r\n            max_distance = 10 * TILE_SIZE\r\n            min_distance = 3 * TILE_SIZE\r\n            center_x = self.player.x\r\n            center_y = self.player.y\r\n        else:\r\n            # Find a position anywhere on the map\r\n            max_distance = min(MAP_WIDTH, MAP_HEIGHT) * TILE_SIZE / 2\r\n            min_distance = 0\r\n            # Use center of map as reference point\r\n            center_x = (MAP_WIDTH * TILE_SIZE) / 2\r\n            center_y = (MAP_HEIGHT * TILE_SIZE) / 2\r\n\r\n        # Try to find a walkable position for the item\r\n        for _ in range(50):  # Limit attempts to avoid infinite loop\r\n            # Random angle\r\n            angle = random.uniform(0, 2 * math.pi)\r\n            # Random distance\r\n            distance = random.uniform(min_distance, max_distance)\r\n\r\n            # Calculate position\r\n            x = center_x + distance * math.cos(angle)\r\n            y = center_y + distance * math.sin(angle)\r\n\r\n            # Ensure position is within map bounds\r\n            x = max(0, min(x, MAP_WIDTH * TILE_SIZE - TILE_SIZE))\r\n            y = max(0, min(y, MAP_HEIGHT * TILE_SIZE - TILE_SIZE))\r\n\r\n            # Check if position is walkable\r\n            if self.map_generator.is_walkable(x, y):\r\n                # Create a random item at this position\r\n                item = Item.create_random_item(x, y, weapon_type)\r\n                self.items.append(item)\r\n                return item\r\n\r\n        return None\r\n\r\n    def spawn_next_tier_weapon(self, current_weapon_type):\r\n        \"\"\"Spawn a weapon of the next tier based on the current weapon type\r\n\r\n        Args:\r\n            current_weapon_type (str): Current weapon type\r\n\r\n        Returns:\r\n            Item: The spawned weapon, or None if no suitable position was found or already at highest tier\r\n        \"\"\"\r\n        # Get the next tier weapon type\r\n        from entities.items import Weapon\r\n        next_weapon_type = Weapon.get_next_tier_weapon(current_weapon_type)\r\n\r\n        # If there is a next tier, spawn it near the player\r\n        if next_weapon_type:\r\n            return self._spawn_random_item(near_player=True, weapon_type=next_weapon_type)\r\n\r\n        return None\r\n\r\n    def handle_event(self, event):\r\n        if event.type == pygame.KEYDOWN:\r\n            if event.key == pygame.K_ESCAPE:\r\n                return \"menu\"\r\n            elif event.key == pygame.K_F1:\r\n                # Toggle debug mode\r\n                self.debug_mode = not self.debug_mode\r\n            elif event.key == pygame.K_r:\r\n                # Reload weapon\r\n                if self.player.weapon:\r\n                    self.player.weapon.reload()\r\n        elif event.type == pygame.MOUSEMOTION:\r\n            # Update player aim based on mouse position\r\n            mouse_pos = pygame.mouse.get_pos()\r\n            camera_offset = (int(self.camera_x), int(self.camera_y))\r\n            self.player.update_aim(mouse_pos, camera_offset)\r\n        elif event.type == pygame.MOUSEBUTTONDOWN:\r\n            if event.button == 1:  # Left mouse button\r\n                # Set flag for continuous firing\r\n                self.left_mouse_down = True\r\n\r\n                # Attempt to shoot immediately\r\n                result = self.player.shoot()\r\n                if result:\r\n                    # Handle different return types from different weapons\r\n                    if isinstance(result, list):\r\n                        # Shotgun returns a list of pellets\r\n                        self.bullets.extend(result)\r\n                    else:\r\n                        # Other weapons return a single bullet\r\n                        self.bullets.append(result)\r\n\r\n                    # Add muzzle flash effect\r\n                    self._add_muzzle_flash_effect()\r\n        elif event.type == pygame.MOUSEBUTTONUP:\r\n            if event.button == 1:  # Left mouse button\r\n                # Clear flag when button is released\r\n                self.left_mouse_down = False\r\n        return None\r\n\r\n    def update(self, dt):\r\n        # Update player with map_generator reference\r\n        self.player.update(dt, self.map_generator)\r\n\r\n        # Handle continuous firing for assault rifle\r\n        if self.left_mouse_down and self.player.weapon and hasattr(self.player.weapon, 'name') and self.player.weapon.name == \"Assault Rifle\":\r\n            result = self.player.shoot()\r\n            if result:\r\n                # Handle different return types from different weapons\r\n                if isinstance(result, list):\r\n                    # Shotgun returns a list of pellets\r\n                    self.bullets.extend(result)\r\n                else:\r\n                    # Other weapons return a single bullet\r\n                    self.bullets.append(result)\r\n\r\n                # Add muzzle flash effect\r\n                self._add_muzzle_flash_effect()\r\n\r\n        # Update zombies with map_generator reference and check for collisions\r\n        zombies_to_remove = []\r\n        for i, zombie in enumerate(self.zombies):\r\n            zombie.update(dt, self.player.x, self.player.y, self.map_generator)\r\n\r\n            # Check for collision with player\r\n            if self._check_collision(zombie, self.player):\r\n                # Zombie attacks player\r\n                zombie.attack(self.player)\r\n\r\n                # Check if player is dead\r\n                if self.player.is_dead():\r\n                    # Handle game over (will be implemented later)\r\n                    print(\"Game Over! Player died.\")\r\n                    # For now, just reset player health\r\n                    self.player.health = 100\r\n\r\n        # Update bullets and check for collisions\r\n        bullets_to_remove = []\r\n        for i, bullet in enumerate(self.bullets):\r\n            # Update bullet position\r\n            bullet.update(dt, self.map_generator)\r\n\r\n            # Check if bullet has expired\r\n            if bullet.is_expired():\r\n                bullets_to_remove.append(i)\r\n                continue\r\n\r\n            # Check for collision with zombies\r\n            for j, zombie in enumerate(self.zombies):\r\n                if self._check_collision(bullet, zombie):\r\n                    # Bullet hit zombie\r\n                    zombie_died = zombie.take_damage(bullet.damage)\r\n\r\n                    # Add blood splatter effect\r\n                    self._add_blood_splatter_effect(zombie.x + zombie.width // 2, zombie.y + zombie.height // 2)\r\n\r\n                    # Mark bullet for removal\r\n                    bullets_to_remove.append(i)\r\n                    break\r\n\r\n            # Check for collision with map (walls)\r\n            if not bullets_to_remove or i not in bullets_to_remove:\r\n                if self.map_generator and not self.map_generator.is_walkable(bullet.x, bullet.y):\r\n                    # Add bullet impact effect\r\n                    self._add_bullet_impact_effect(bullet.x, bullet.y, bullet.color)\r\n\r\n                    # Mark bullet for removal\r\n                    bullets_to_remove.append(i)\r\n\r\n        # Remove expired or collided bullets\r\n        self.bullets = [b for i, b in enumerate(self.bullets) if i not in bullets_to_remove]\r\n\r\n        # Remove dead zombies\r\n        self.zombies = [zombie for zombie in self.zombies if not zombie.is_dead()]\r\n\r\n        # Check for item pickups\r\n        for item in self.items:\r\n            if not item.picked_up and self._check_collision(item, self.player):\r\n                # Item is picked up by player\r\n                message = item.pickup(self.player)\r\n                self.pickup_message = message\r\n                self.pickup_timer = PICKUP_NOTIFICATION_DURATION\r\n\r\n        # Update pickup notification timer\r\n        if self.pickup_timer > 0:\r\n            self.pickup_timer -= dt\r\n\r\n        # Update effects\r\n        effects_to_remove = []\r\n        for i, effect in enumerate(self.effects):\r\n            effect.update(dt)\r\n            if effect.finished:\r\n                effects_to_remove.append(i)\r\n\r\n        # Remove finished effects\r\n        self.effects = [e for i, e in enumerate(self.effects) if i not in effects_to_remove]\r\n\r\n        # Update camera position to follow player (with smoothing)\r\n        target_camera_x = self.player.x - WINDOW_WIDTH // 2\r\n        target_camera_y = self.player.y - WINDOW_HEIGHT // 2\r\n\r\n        # Apply camera smoothing\r\n        self.camera_x += (target_camera_x - self.camera_x) * CAMERA_LERP\r\n        self.camera_y += (target_camera_y - self.camera_y) * CAMERA_LERP\r\n\r\n        # Calculate map boundaries in pixels\r\n        map_width_px = MAP_WIDTH * TILE_SIZE\r\n        map_height_px = MAP_HEIGHT * TILE_SIZE\r\n\r\n        # Constrain camera to map boundaries\r\n        # Left boundary\r\n        if self.camera_x < 0:\r\n            self.camera_x = 0\r\n        # Right boundary (map width - screen width)\r\n        elif self.camera_x > map_width_px - WINDOW_WIDTH:\r\n            self.camera_x = map_width_px - WINDOW_WIDTH\r\n\r\n        # Top boundary\r\n        if self.camera_y < 0:\r\n            self.camera_y = 0\r\n        # Bottom boundary (map height - screen height)\r\n        elif self.camera_y > map_height_px - WINDOW_HEIGHT:\r\n            self.camera_y = map_height_px - WINDOW_HEIGHT\r\n\r\n    def render(self, screen, fps=0):\r\n        # Calculate camera offset for rendering\r\n        camera_offset = (int(self.camera_x), int(self.camera_y))\r\n\r\n        # Draw the map with camera offset\r\n        self.map_generator.render(screen, camera_offset)\r\n\r\n        # Draw items with camera offset\r\n        for item in self.items:\r\n            item.render(screen, camera_offset)\r\n\r\n        # Draw bullets with camera offset\r\n        for bullet in self.bullets:\r\n            bullet.render(screen, camera_offset)\r\n\r\n        # Draw zombies with camera offset\r\n        for zombie in self.zombies:\r\n            zombie.render(screen, camera_offset)\r\n\r\n        # Draw player with camera offset\r\n        self.player.render(screen, camera_offset)\r\n\r\n        # Draw effects with camera offset\r\n        for effect in self.effects:\r\n            effect.render(screen, camera_offset)\r\n\r\n        # Draw pickup notification if active\r\n        if self.pickup_timer > 0:\r\n            # Create a font for the notification\r\n            notification_font = pygame.font.Font(None, 36)\r\n\r\n            # Render the notification text\r\n            notification_text = notification_font.render(self.pickup_message, True, WHITE)\r\n\r\n            # Position the notification at the top center of the screen\r\n            text_rect = notification_text.get_rect(center=(WINDOW_WIDTH // 2, 50))\r\n\r\n            # Draw the notification\r\n            screen.blit(notification_text, text_rect)\r\n\r\n        # Render debug information if debug mode is enabled\r\n        if self.debug_mode:\r\n            self._render_debug_info(screen, fps)\r\n\r\n    def _check_collision(self, entity1, entity2):\r\n        \"\"\"Check if two entities are colliding\r\n\r\n        Args:\r\n            entity1: First entity\r\n            entity2: Second entity\r\n\r\n        Returns:\r\n            bool: True if entities are colliding, False otherwise\r\n        \"\"\"\r\n        # Calculate distance between entity centers\r\n        dx = entity1.x + entity1.width/2 - (entity2.x + entity2.width/2)\r\n        dy = entity1.y + entity1.height/2 - (entity2.y + entity2.height/2)\r\n        distance = (dx * dx + dy * dy) ** 0.5\r\n\r\n        # Check if distance is less than sum of radii (using width as diameter)\r\n        return distance < (entity1.width + entity2.width) / 2\r\n\r\n    def _add_muzzle_flash_effect(self):\r\n        \"\"\"Add a muzzle flash effect at the player's weapon position\"\"\"\r\n        if not self.player.weapon:\r\n            return\r\n\r\n        # Calculate muzzle position (slightly in front of player in aim direction)\r\n        spawn_distance = self.player.width // 2 + 5  # 5 pixels in front of player edge\r\n        muzzle_x = self.player.x + self.player.width // 2 + math.cos(self.player.aim_angle) * spawn_distance\r\n        muzzle_y = self.player.y + self.player.height // 2 + math.sin(self.player.aim_angle) * spawn_distance\r\n\r\n        # Create muzzle flash effect\r\n        flash = MuzzleFlash(muzzle_x, muzzle_y, self.player.aim_angle)\r\n        self.effects.append(flash)\r\n\r\n    def _add_bullet_impact_effect(self, x, y, color=None):\r\n        \"\"\"Add a bullet impact effect at the specified position\r\n\r\n        Args:\r\n            x (float): X position\r\n            y (float): Y position\r\n            color (tuple, optional): Color of the impact\r\n        \"\"\"\r\n        # Use bullet color if provided, otherwise use white\r\n        impact_color = color or (255, 255, 255)\r\n\r\n        # Create bullet impact effect\r\n        impact = BulletImpact(x, y, impact_color)\r\n        self.effects.append(impact)\r\n\r\n    def _add_blood_splatter_effect(self, x, y):\r\n        \"\"\"Add a blood splatter effect at the specified position\r\n\r\n        Args:\r\n            x (float): X position\r\n            y (float): Y position\r\n        \"\"\"\r\n        # Create blood splatter effect\r\n        splatter = BloodSplatter(x, y)\r\n        self.effects.append(splatter)\r\n\r\n    def _render_debug_info(self, screen, fps):\r\n        \"\"\"Render debug information on the screen\"\"\"\r\n        # Create debug text lines\r\n        debug_lines = [\r\n            f\"FPS: {fps:.1f}\",\r\n            f\"Player Health: {self.player.health}/{PLAYER_MAX_HEALTH}\",\r\n            f\"Player Position: ({self.player.x:.1f}, {self.player.y:.1f})\",\r\n            f\"Tile Position: ({int(self.player.x // TILE_SIZE)}, {int(self.player.y // TILE_SIZE)})\",\r\n            f\"On Object: {self.player.is_on_object}\",\r\n            f\"Speed Multiplier: {self.player.debug_speed_multiplier:.1f}\",\r\n            f\"Zombies: {len(self.zombies)}\",\r\n            f\"Items: {len(self.items)}\",\r\n            f\"Bullets: {len(self.bullets)}\",\r\n            f\"Effects: {len(self.effects)}\",\r\n            f\"Weapon: {self.player.weapon.name if self.player.weapon else 'None'}\",\r\n            f\"Ammo: {self.player.weapon.ammo}/{self.player.weapon.magazine_size if self.player.weapon else 0}\",\r\n            f\"Reloading: {self.player.weapon.is_reloading if self.player.weapon else False}\",\r\n            f\"Pickup Message: {self.pickup_message if self.pickup_timer > 0 else 'None'}\"\r\n        ]\r\n\r\n        # Render each line of debug text\r\n        y_offset = 10\r\n        for line in debug_lines:\r\n            debug_text = self.debug_font.render(line, True, DEBUG_TEXT_COLOR)\r\n            screen.blit(debug_text, (10, y_offset))\r\n            y_offset += DEBUG_FONT_SIZE + 5  # Add some spacing between lines\r\n\r\n\r\nclass GameStateManager:\r\n    \"\"\"Game state manager\"\"\"\r\n\r\n    def __init__(self):\r\n        self.states = {\r\n            \"menu\": MenuState(),\r\n            \"gameplay\": GameplayState()\r\n        }\r\n        self.current_state = \"menu\"\r\n\r\n    def handle_event(self, event):\r\n        new_state = self.states[self.current_state].handle_event(event)\r\n        if new_state and new_state in self.states:\r\n            self.current_state = new_state\r\n\r\n    def update(self, dt):\r\n        self.states[self.current_state].update(dt)\r\n\r\n    def render(self, screen, fps=0):\r\n        self.states[self.current_state].render(screen, fps)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/game/game_state.py b/src/game/game_state.py
--- a/src/game/game_state.py	(revision 4bce95d1d51963b52aa711b95eef7c6fa02c202d)
+++ b/src/game/game_state.py	(date 1749912417601)
@@ -338,9 +338,9 @@
                     bullets_to_remove.append(i)
                     break
 
-            # Check for collision with map (walls)
+            # Check for collision with map (walls and objects)
             if not bullets_to_remove or i not in bullets_to_remove:
-                if self.map_generator and not self.map_generator.is_walkable(bullet.x, bullet.y):
+                if self.map_generator and not self.map_generator.is_bullet_passable(bullet.x, bullet.y):
                     # Add bullet impact effect
                     self._add_bullet_impact_effect(bullet.x, bullet.y, bullet.color)
 
Index: src/entities/zombies.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport math\r\nfrom entities.entity import Entity\r\nfrom utils.constants import (\r\n    BLACK, ENEMY_SIZE, ENEMY_SPEED, OBJECT_SPEED_MULTIPLIER, TILE_OBJECT, \r\n    ZOMBIE_HEALTH, ZOMBIE_DAMAGE, ZOMBIE_ATTACK_COOLDOWN,\r\n    TOUGH_ZOMBIE_HEALTH, TOUGH_ZOMBIE_DAMAGE, TOUGH_ZOMBIE_SPEED,\r\n    RED\r\n)\r\n\r\nclass Zombie(Entity):\r\n    \"\"\"Zombie entity that follows the player\"\"\"\r\n\r\n    def __init__(self, x, y):\r\n        \"\"\"Initialize the zombie\r\n\r\n        Args:\r\n            x (float): Initial x position\r\n            y (float): Initial y position\r\n        \"\"\"\r\n        super().__init__(x, y, ENEMY_SIZE, ENEMY_SIZE, BLACK)\r\n        self.speed = ENEMY_SPEED\r\n        self.is_on_object = False  # Flag to track if zombie is on an object\r\n        self.map_generator = None  # Will be set by GameplayState\r\n        self.health = ZOMBIE_HEALTH\r\n        self.attack_timer = 0  # Timer for attack cooldown\r\n\r\n    def update(self, dt, player_x, player_y, map_generator=None):\r\n        \"\"\"Update zombie state to move towards player\r\n\r\n        Args:\r\n            dt (float): Time delta in seconds\r\n            player_x (float): Player's x position\r\n            player_y (float): Player's y position\r\n            map_generator (MapGenerator, optional): Reference to the map generator\r\n        \"\"\"\r\n        # Store map_generator reference if provided\r\n        if map_generator:\r\n            self.map_generator = map_generator\r\n\r\n        # Update attack timer\r\n        if self.attack_timer > 0:\r\n            self.attack_timer -= dt\r\n\r\n        # Calculate direction vector to player\r\n        dx = player_x - self.x\r\n        dy = player_y - self.y\r\n\r\n        # Normalize the direction vector\r\n        distance = math.sqrt(dx * dx + dy * dy)\r\n\r\n        # Calculate base speed\r\n        base_speed = self.speed\r\n\r\n        # Check if zombie is on an object and apply speed multiplier if needed\r\n        self.is_on_object = False\r\n        if self.map_generator:\r\n            tile_type = self.map_generator.get_tile_at(self.x + self.width // 2, self.y + self.height // 2)\r\n            if tile_type == TILE_OBJECT:\r\n                self.is_on_object = True\r\n                base_speed *= OBJECT_SPEED_MULTIPLIER\r\n\r\n        # Only move if not already at player position\r\n        if distance > 0:\r\n            dx /= distance\r\n            dy /= distance\r\n\r\n            # Move towards player with potentially reduced speed\r\n            self.x += dx * base_speed * dt\r\n            self.y += dy * base_speed * dt\r\n\r\n        # Call parent update to update rect\r\n        super().update(dt)\r\n\r\n    def attack(self, player):\r\n        \"\"\"Attack the player if cooldown has expired\r\n\r\n        Args:\r\n            player: The player to attack\r\n\r\n        Returns:\r\n            bool: True if attack was successful, False otherwise\r\n        \"\"\"\r\n        if self.attack_timer <= 0:\r\n            # Reset attack timer\r\n            self.attack_timer = ZOMBIE_ATTACK_COOLDOWN\r\n\r\n            # Deal damage to player\r\n            return player.take_damage(ZOMBIE_DAMAGE)\r\n\r\n        return False\r\n\r\n    def take_damage(self, amount):\r\n        \"\"\"Reduce zombie health by the specified amount\r\n\r\n        Args:\r\n            amount (int): Amount of damage to take\r\n\r\n        Returns:\r\n            bool: True if zombie died, False otherwise\r\n        \"\"\"\r\n        self.health -= amount\r\n        if self.health <= 0:\r\n            self.health = 0\r\n            return True  # Zombie died\r\n        return False\r\n\r\n    def is_dead(self):\r\n        \"\"\"Check if the zombie is dead\r\n\r\n        Returns:\r\n            bool: True if zombie health is 0, False otherwise\r\n        \"\"\"\r\n        return self.health <= 0\r\n\r\n    def render(self, screen, camera_offset=(0, 0)):\r\n        \"\"\"Render the zombie as a black circle\r\n\r\n        Args:\r\n            screen (pygame.Surface): Screen to render on\r\n            camera_offset (tuple): Camera offset (x, y)\r\n        \"\"\"\r\n        # Calculate center position\r\n        center_x = self.rect.x + self.width // 2 - camera_offset[0]\r\n        center_y = self.rect.y + self.height // 2 - camera_offset[1]\r\n\r\n        # Create a transparent surface for the zombie when on an object\r\n        if self.is_on_object:\r\n            # Create a surface with per-pixel alpha\r\n            circle_surface = pygame.Surface((self.width, self.height), pygame.SRCALPHA)\r\n            # Draw a semi-transparent circle (128 is 50% opacity)\r\n            pygame.draw.circle(circle_surface, (*self.color, 128), (self.width // 2, self.height // 2), self.width // 2)\r\n            # Blit the surface to the screen\r\n            screen.blit(circle_surface, (center_x - self.width // 2, center_y - self.height // 2))\r\n        else:\r\n            # Draw zombie normally when not on an object\r\n            pygame.draw.circle(screen, self.color, (center_x, center_y), self.width // 2)\r\n\r\n\r\nclass ToughZombie(Zombie):\r\n    \"\"\"Tougher zombie entity that follows the player but is slower\"\"\"\r\n\r\n    def __init__(self, x, y):\r\n        \"\"\"Initialize the tough zombie\r\n\r\n        Args:\r\n            x (float): Initial x position\r\n            y (float): Initial y position\r\n        \"\"\"\r\n        # Call parent constructor\r\n        super().__init__(x, y)\r\n\r\n        # Override properties for tough zombie\r\n        self.color = RED\r\n        self.speed = TOUGH_ZOMBIE_SPEED\r\n        self.health = TOUGH_ZOMBIE_HEALTH\r\n\r\n    def attack(self, player):\r\n        \"\"\"Attack the player if cooldown has expired\r\n\r\n        Args:\r\n            player: The player to attack\r\n\r\n        Returns:\r\n            bool: True if attack was successful, False otherwise\r\n        \"\"\"\r\n        if self.attack_timer <= 0:\r\n            # Reset attack timer\r\n            self.attack_timer = ZOMBIE_ATTACK_COOLDOWN\r\n\r\n            # Deal damage to player (more damage than regular zombie)\r\n            return player.take_damage(TOUGH_ZOMBIE_DAMAGE)\r\n\r\n        return False\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/entities/zombies.py b/src/entities/zombies.py
--- a/src/entities/zombies.py	(revision 4bce95d1d51963b52aa711b95eef7c6fa02c202d)
+++ b/src/entities/zombies.py	(date 1749911671280)
@@ -65,9 +65,37 @@
             dx /= distance
             dy /= distance
 
-            # Move towards player with potentially reduced speed
-            self.x += dx * base_speed * dt
-            self.y += dy * base_speed * dt
+            # Calculate new position
+            new_x = self.x + dx * base_speed * dt
+            new_y = self.y + dy * base_speed * dt
+
+            # Check if the new position is walkable (not a wall)
+            if self.map_generator:
+                # Try horizontal movement first
+                horizontal_walkable = True
+                for corner_x, corner_y in [(new_x, self.y), (new_x + self.width - 1, self.y), 
+                                          (new_x, self.y + self.height - 1), (new_x + self.width - 1, self.y + self.height - 1)]:
+                    if not self.map_generator.is_walkable(corner_x, corner_y):
+                        horizontal_walkable = False
+                        break
+
+                # Try vertical movement
+                vertical_walkable = True
+                for corner_x, corner_y in [(self.x, new_y), (self.x + self.width - 1, new_y), 
+                                          (self.x, new_y + self.height - 1), (self.x + self.width - 1, new_y + self.height - 1)]:
+                    if not self.map_generator.is_walkable(corner_x, corner_y):
+                        vertical_walkable = False
+                        break
+
+                # Apply movements that are walkable
+                if horizontal_walkable:
+                    self.x = new_x
+                if vertical_walkable:
+                    self.y = new_y
+            else:
+                # If no map_generator is provided, just update position
+                self.x = new_x
+                self.y = new_y
 
         # Call parent update to update rect
         super().update(dt)
Index: src/entities/player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport math\r\nfrom entities.entity import Entity\r\nfrom systems.weapons import Pistol\r\nfrom utils.constants import RED, PLAYER_SIZE, PLAYER_SPEED, TILE_SIZE, MAP_WIDTH, MAP_HEIGHT, OBJECT_SPEED_MULTIPLIER, TILE_OBJECT, PLAYER_MAX_HEALTH\r\n\r\nclass Player(Entity):\r\n    \"\"\"Player entity controlled by the user\"\"\"\r\n\r\n    def __init__(self, x, y):\r\n        \"\"\"Initialize the player\r\n\r\n        Args:\r\n            x (float): Initial x position\r\n            y (float): Initial y position\r\n        \"\"\"\r\n        super().__init__(x, y, PLAYER_SIZE, PLAYER_SIZE, RED)\r\n        self.speed = PLAYER_SPEED\r\n        self.debug_speed_multiplier = 1.0\r\n        self.is_on_object = False  # Flag to track if player is on an object\r\n        self.map_generator = None  # Will be set by GameplayState\r\n        self.health = PLAYER_MAX_HEALTH\r\n        self.is_invulnerable = False  # Flag for temporary invulnerability after taking damage\r\n        self.invulnerability_timer = 0  # Timer for invulnerability\r\n\r\n        # Weapon handling\r\n        self.weapon = Pistol()  # Start with a pistol\r\n        self.aim_angle = 0  # Angle in radians (0 = right, pi/2 = down)\r\n\r\n    def update(self, dt, map_generator=None):\r\n        \"\"\"Update player state based on input\r\n\r\n        Args:\r\n            dt (float): Time delta in seconds\r\n            map_generator (MapGenerator, optional): Reference to the map generator\r\n        \"\"\"\r\n        # Store map_generator reference if provided\r\n        if map_generator:\r\n            self.map_generator = map_generator\r\n\r\n        # Update invulnerability timer if player is invulnerable\r\n        if self.is_invulnerable:\r\n            self.invulnerability_timer -= dt\r\n            if self.invulnerability_timer <= 0:\r\n                self.is_invulnerable = False\r\n                self.invulnerability_timer = 0\r\n\r\n        # Get keyboard input\r\n        keys = pygame.key.get_pressed()\r\n\r\n        # Check for debug speed boost with Shift key\r\n        if keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]:\r\n            self.debug_speed_multiplier = 3.0  # 3x speed when Shift is pressed\r\n        else:\r\n            self.debug_speed_multiplier = 1.0\r\n\r\n        # Calculate base speed with debug multiplier\r\n        base_speed = self.speed * self.debug_speed_multiplier\r\n\r\n        # Check if player is on an object and apply speed multiplier if needed\r\n        self.is_on_object = False\r\n        if self.map_generator:\r\n            tile_type = self.map_generator.get_tile_at(self.x + self.width // 2, self.y + self.height // 2)\r\n            if tile_type == TILE_OBJECT:\r\n                self.is_on_object = True\r\n                base_speed *= OBJECT_SPEED_MULTIPLIER\r\n\r\n        # Store previous position for collision detection\r\n        prev_x, prev_y = self.x, self.y\r\n\r\n        # Move player based on arrow keys or WASD\r\n        if keys[pygame.K_LEFT] or keys[pygame.K_a]:\r\n            self.x -= base_speed * dt\r\n        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:\r\n            self.x += base_speed * dt\r\n        if keys[pygame.K_UP] or keys[pygame.K_w]:\r\n            self.y -= base_speed * dt\r\n        if keys[pygame.K_DOWN] or keys[pygame.K_s]:\r\n            self.y += base_speed * dt\r\n\r\n        # Boundary checking to prevent player from leaving the map\r\n        map_width_px = MAP_WIDTH * TILE_SIZE\r\n        map_height_px = MAP_HEIGHT * TILE_SIZE\r\n\r\n        # Keep player within map boundaries\r\n        self.x = max(0, min(self.x, map_width_px - self.width))\r\n        self.y = max(0, min(self.y, map_height_px - self.height))\r\n\r\n        # Update weapon\r\n        if self.weapon:\r\n            self.weapon.update(dt)\r\n\r\n            # Handle reload with R key\r\n            if keys[pygame.K_r]:\r\n                self.weapon.reload()\r\n\r\n        # Call parent update to update rect\r\n        super().update(dt)\r\n\r\n    def take_damage(self, amount):\r\n        \"\"\"Reduce player health by the specified amount if not invulnerable\r\n\r\n        Args:\r\n            amount (int): Amount of damage to take\r\n\r\n        Returns:\r\n            bool: True if damage was taken, False if invulnerable\r\n        \"\"\"\r\n        if self.is_invulnerable:\r\n            return False\r\n\r\n        self.health -= amount\r\n        if self.health < 0:\r\n            self.health = 0\r\n\r\n        # Make player invulnerable for a short time after taking damage\r\n        self.is_invulnerable = True\r\n        self.invulnerability_timer = 0.5  # Half a second of invulnerability\r\n\r\n        return True\r\n\r\n    def is_dead(self):\r\n        \"\"\"Check if the player is dead\r\n\r\n        Returns:\r\n            bool: True if player health is 0, False otherwise\r\n        \"\"\"\r\n        return self.health <= 0\r\n\r\n    def update_aim(self, mouse_pos, camera_offset):\r\n        \"\"\"Update the aim angle based on mouse position\r\n\r\n        Args:\r\n            mouse_pos (tuple): Mouse position (x, y)\r\n            camera_offset (tuple): Camera offset (x, y)\r\n        \"\"\"\r\n        # Calculate player center in screen coordinates\r\n        player_center_x = self.rect.x + self.width // 2 - camera_offset[0]\r\n        player_center_y = self.rect.y + self.height // 2 - camera_offset[1]\r\n\r\n        # Calculate vector from player to mouse\r\n        dx = mouse_pos[0] - player_center_x\r\n        dy = mouse_pos[1] - player_center_y\r\n\r\n        # Calculate angle (atan2 returns angle in radians)\r\n        self.aim_angle = math.atan2(dy, dx)\r\n\r\n    def shoot(self):\r\n        \"\"\"Attempt to shoot a bullet\r\n\r\n        Returns:\r\n            Bullet or None: A new bullet if shot was successful, None otherwise\r\n        \"\"\"\r\n        if self.weapon and self.weapon.can_shoot():\r\n            # Calculate bullet spawn position (slightly in front of player in aim direction)\r\n            spawn_distance = self.width // 2 + 5  # 5 pixels in front of player edge\r\n            spawn_x = self.x + self.width // 2 + math.cos(self.aim_angle) * spawn_distance\r\n            spawn_y = self.y + self.height // 2 + math.sin(self.aim_angle) * spawn_distance\r\n\r\n            # Shoot the weapon\r\n            return self.weapon.shoot(spawn_x, spawn_y, self.aim_angle)\r\n\r\n        return None\r\n\r\n    def render(self, screen, camera_offset=(0, 0)):\r\n        \"\"\"Render the player as a circle with aim direction\r\n\r\n        Args:\r\n            screen (pygame.Surface): Screen to render on\r\n            camera_offset (tuple): Camera offset (x, y)\r\n        \"\"\"\r\n        # Calculate center position\r\n        center_x = self.rect.x + self.width // 2 - camera_offset[0]\r\n        center_y = self.rect.y + self.height // 2 - camera_offset[1]\r\n\r\n        # Create a transparent surface for the player when on an object\r\n        if self.is_on_object:\r\n            # Create a surface with per-pixel alpha\r\n            circle_surface = pygame.Surface((self.width, self.height), pygame.SRCALPHA)\r\n            # Draw a semi-transparent circle (128 is 50% opacity)\r\n            pygame.draw.circle(circle_surface, (*self.color, 128), (self.width // 2, self.height // 2), self.width // 2)\r\n            # Blit the surface to the screen\r\n            screen.blit(circle_surface, (center_x - self.width // 2, center_y - self.height // 2))\r\n        else:\r\n            # Draw player normally when not on an object\r\n            pygame.draw.circle(screen, self.color, (center_x, center_y), self.width // 2)\r\n\r\n        # Draw aim direction line\r\n        line_length = self.width  # Length of the aim line\r\n        end_x = center_x + math.cos(self.aim_angle) * line_length\r\n        end_y = center_y + math.sin(self.aim_angle) * line_length\r\n        pygame.draw.line(screen, (0, 0, 0), (center_x, center_y), (end_x, end_y), 2)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/entities/player.py b/src/entities/player.py
--- a/src/entities/player.py	(revision 4bce95d1d51963b52aa711b95eef7c6fa02c202d)
+++ b/src/entities/player.py	(date 1749911639120)
@@ -68,23 +68,61 @@
         # Store previous position for collision detection
         prev_x, prev_y = self.x, self.y
 
-        # Move player based on arrow keys or WASD
+        # Calculate new position based on keyboard input
+        new_x, new_y = self.x, self.y
+
         if keys[pygame.K_LEFT] or keys[pygame.K_a]:
-            self.x -= base_speed * dt
+            new_x -= base_speed * dt
         if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
-            self.x += base_speed * dt
+            new_x += base_speed * dt
         if keys[pygame.K_UP] or keys[pygame.K_w]:
-            self.y -= base_speed * dt
+            new_y -= base_speed * dt
         if keys[pygame.K_DOWN] or keys[pygame.K_s]:
-            self.y += base_speed * dt
+            new_y += base_speed * dt
 
         # Boundary checking to prevent player from leaving the map
         map_width_px = MAP_WIDTH * TILE_SIZE
         map_height_px = MAP_HEIGHT * TILE_SIZE
 
         # Keep player within map boundaries
-        self.x = max(0, min(self.x, map_width_px - self.width))
-        self.y = max(0, min(self.y, map_height_px - self.height))
+        new_x = max(0, min(new_x, map_width_px - self.width))
+        new_y = max(0, min(new_y, map_height_px - self.height))
+
+        # Check if the new position is walkable (not a wall)
+        if self.map_generator:
+            # Check each corner of the player's bounding box
+            corners = [
+                (new_x, new_y),  # Top-left
+                (new_x + self.width - 1, new_y),  # Top-right
+                (new_x, new_y + self.height - 1),  # Bottom-left
+                (new_x + self.width - 1, new_y + self.height - 1)  # Bottom-right
+            ]
+
+            # Try horizontal movement first
+            horizontal_walkable = True
+            for corner_x, corner_y in [(new_x, self.y), (new_x + self.width - 1, self.y), 
+                                      (new_x, self.y + self.height - 1), (new_x + self.width - 1, self.y + self.height - 1)]:
+                if not self.map_generator.is_walkable(corner_x, corner_y):
+                    horizontal_walkable = False
+                    break
+
+            # Try vertical movement
+            vertical_walkable = True
+            for corner_x, corner_y in [(self.x, new_y), (self.x + self.width - 1, new_y), 
+                                      (self.x, new_y + self.height - 1), (self.x + self.width - 1, new_y + self.height - 1)]:
+                if not self.map_generator.is_walkable(corner_x, corner_y):
+                    vertical_walkable = False
+                    break
+
+            # Apply movements that are walkable
+            if horizontal_walkable:
+                self.x = new_x
+            if vertical_walkable:
+                self.y = new_y
+        else:
+            # If no map_generator is provided, just update position
+            self.x = new_x
+            self.y = new_y
 
         # Update weapon
         if self.weapon:
Index: src/game/map_generator.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import random\r\nimport pygame\r\nfrom utils.constants import (\r\n    TILE_SIZE, MAP_WIDTH, MAP_HEIGHT, EDGE_THICKNESS,\r\n    TILE_GRASS, TILE_OBJECT, TILE_WALL, TILE_WOOD,\r\n    TILE_COLORS, MIN_BUILDINGS, MAX_BUILDINGS, RANDOM_OBJECT_DENSITY\r\n)\r\nfrom game.building_templates import SMALL_BUILDINGS, MEDIUM_BUILDINGS, LARGE_BUILDINGS, ALL_BUILDINGS\r\n\r\nclass MapGenerator:\r\n    \"\"\"Map generator for the game\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the map generator\"\"\"\r\n        # Create an empty map matrix\r\n        self.map_data = [[TILE_GRASS for _ in range(MAP_WIDTH)] for _ in range(MAP_HEIGHT)]\r\n\r\n        # Generate the map\r\n        self._generate_map()\r\n\r\n        # Create a surface for the map\r\n        self.map_surface = self._create_map_surface()\r\n\r\n    def _generate_map(self):\r\n        \"\"\"Generate the map with grass, objects, walls, and wood\"\"\"\r\n        # Step 1: Fill the entire map with grass (already done in initialization)\r\n\r\n        # Step 2: Add dense forest (objects) around the edges\r\n        self._add_forest_edge()\r\n\r\n        # Step 3: Add buildings according to templates\r\n        self._add_buildings()\r\n\r\n        # Step 4: Add random objects throughout the map\r\n        self._add_random_objects()\r\n\r\n    def _add_forest_edge(self):\r\n        \"\"\"Add a dense forest around the edges of the map\"\"\"\r\n        # Add objects along the top and bottom edges\r\n        for x in range(MAP_WIDTH):\r\n            for y in range(EDGE_THICKNESS):\r\n                # Top edge\r\n                if random.random() < 0.4:  # 40% chance for an object\r\n                    self.map_data[y][x] = TILE_OBJECT\r\n\r\n                # Bottom edge\r\n                if random.random() < 0.4:\r\n                    self.map_data[MAP_HEIGHT - 1 - y][x] = TILE_OBJECT\r\n\r\n        # Add objects along the left and right edges\r\n        for y in range(MAP_HEIGHT):\r\n            for x in range(EDGE_THICKNESS):\r\n                # Left edge\r\n                if random.random() < 0.4:\r\n                    self.map_data[y][x] = TILE_OBJECT\r\n\r\n                # Right edge\r\n                if random.random() < 0.4:\r\n                    self.map_data[y][MAP_WIDTH - 1 - x] = TILE_OBJECT\r\n\r\n    def _add_buildings(self):\r\n        \"\"\"Add buildings to the map using templates from building_templates.py\"\"\"\r\n        # Determine how many buildings to add\r\n        num_buildings = random.randint(MIN_BUILDINGS, MAX_BUILDINGS)\r\n\r\n        # Keep track of building positions to prevent overlapping\r\n        building_positions = []\r\n\r\n        # Try to place each building\r\n        for _ in range(num_buildings):\r\n            # Randomly select a building template category with weighted probability\r\n            # More small buildings, fewer large ones\r\n            template_category = random.choices(\r\n                [SMALL_BUILDINGS, MEDIUM_BUILDINGS, LARGE_BUILDINGS],\r\n                weights=[0.5, 0.3, 0.2],\r\n                k=1\r\n            )[0]\r\n\r\n            # Randomly select a template from the category\r\n            building_template = random.choice(template_category)\r\n            template_size = len(building_template)\r\n\r\n            # Try to find a valid position for the building (not overlapping with existing buildings)\r\n            max_attempts = 50  # Limit the number of attempts to avoid infinite loop\r\n            overlaps = True\r\n\r\n            for attempt in range(max_attempts):\r\n                # Choose a random position for the building (away from edges)\r\n                x = random.randint(EDGE_THICKNESS + 2, MAP_WIDTH - EDGE_THICKNESS - template_size - 2)\r\n                y = random.randint(EDGE_THICKNESS + 2, MAP_HEIGHT - EDGE_THICKNESS - template_size - 2)\r\n\r\n                # Check if this position overlaps with any existing building\r\n                overlaps = False\r\n                for bx, by, bs in building_positions:\r\n                    # Check if buildings would overlap (with a small buffer)\r\n                    if (abs(x - bx) < (template_size + bs) // 2 and \r\n                        abs(y - by) < (template_size + bs) // 2):\r\n                        overlaps = True\r\n                        break\r\n\r\n                # If no overlap, we can place the building here\r\n                if not overlaps:\r\n                    building_positions.append((x, y, template_size))\r\n                    break\r\n\r\n            # If we couldn't find a valid position after max_attempts, skip this building\r\n            if overlaps:\r\n                continue\r\n\r\n            # Apply the template to the map\r\n            for ty in range(template_size):\r\n                for tx in range(template_size):\r\n                    template_value = building_template[ty][tx]\r\n                    # Only change if template specifies a tile (not 0)\r\n                    if template_value == 1:\r\n                        self.map_data[y + ty][x + tx] = TILE_WALL\r\n                    elif template_value == 2:\r\n                        self.map_data[y + ty][x + tx] = TILE_WOOD\r\n\r\n    def _add_random_objects(self):\r\n        \"\"\"Add random objects throughout the map\"\"\"\r\n        # Add objects randomly throughout the map (excluding edges and buildings)\r\n        for y in range(EDGE_THICKNESS, MAP_HEIGHT - EDGE_THICKNESS):\r\n            for x in range(EDGE_THICKNESS, MAP_WIDTH - EDGE_THICKNESS):\r\n                # Skip if the tile is already a wall or wood (part of a building)\r\n                if self.map_data[y][x] == TILE_WALL or self.map_data[y][x] == TILE_WOOD:\r\n                    continue\r\n\r\n                # Use RANDOM_OBJECT_DENSITY to determine chance to place an object\r\n                if random.random() < RANDOM_OBJECT_DENSITY:\r\n                    self.map_data[y][x] = TILE_OBJECT\r\n\r\n    def _create_map_surface(self):\r\n        \"\"\"Create a surface with the map rendered on it\"\"\"\r\n        # Create a surface large enough for the entire map\r\n        surface_width = MAP_WIDTH * TILE_SIZE\r\n        surface_height = MAP_HEIGHT * TILE_SIZE\r\n        surface = pygame.Surface((surface_width, surface_height))\r\n\r\n        # Draw each tile on the surface\r\n        for y in range(MAP_HEIGHT):\r\n            for x in range(MAP_WIDTH):\r\n                tile_type = self.map_data[y][x]\r\n                tile_color = TILE_COLORS[tile_type]\r\n\r\n                # Draw the tile as a rectangle\r\n                rect = pygame.Rect(\r\n                    x * TILE_SIZE, \r\n                    y * TILE_SIZE, \r\n                    TILE_SIZE, \r\n                    TILE_SIZE\r\n                )\r\n                pygame.draw.rect(surface, tile_color, rect)\r\n\r\n                # Add a slight border to make tiles more visible\r\n                pygame.draw.rect(surface, (0, 0, 0), rect, 1)\r\n\r\n        return surface\r\n\r\n    def get_tile_at(self, x, y):\r\n        \"\"\"Get the tile type at the specified world coordinates\"\"\"\r\n        # Convert world coordinates to tile coordinates\r\n        tile_x = int(x // TILE_SIZE)\r\n        tile_y = int(y // TILE_SIZE)\r\n\r\n        # Check if the coordinates are within the map bounds\r\n        if 0 <= tile_x < MAP_WIDTH and 0 <= tile_y < MAP_HEIGHT:\r\n            return self.map_data[tile_y][tile_x]\r\n\r\n        # Return object (forest) for out-of-bounds coordinates\r\n        return TILE_OBJECT\r\n\r\n    def is_walkable(self, x, y):\r\n        \"\"\"Check if the specified world coordinates are walkable\"\"\"\r\n        tile_type = self.get_tile_at(x, y)\r\n\r\n        # Only grass is walkable\r\n        return tile_type == TILE_GRASS\r\n\r\n    def render(self, screen, camera_offset):\r\n        \"\"\"Render the map to the screen with the specified camera offset\"\"\"\r\n        # Calculate the visible portion of the map based on camera offset\r\n        view_rect = pygame.Rect(\r\n            camera_offset[0], \r\n            camera_offset[1], \r\n            screen.get_width(), \r\n            screen.get_height()\r\n        )\r\n\r\n        # Blit the visible portion of the map to the screen\r\n        # The destination position is (0, 0) because we're blitting the already-offset portion\r\n        screen.blit(self.map_surface, (0, 0), view_rect)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/game/map_generator.py b/src/game/map_generator.py
--- a/src/game/map_generator.py	(revision 4bce95d1d51963b52aa711b95eef7c6fa02c202d)
+++ b/src/game/map_generator.py	(date 1749911896529)
@@ -174,8 +174,15 @@
         """Check if the specified world coordinates are walkable"""
         tile_type = self.get_tile_at(x, y)
 
-        # Only grass is walkable
-        return tile_type == TILE_GRASS
+        # Grass, object, and wood are walkable, but not walls
+        return tile_type in [TILE_GRASS, TILE_OBJECT, TILE_WOOD]
+
+    def is_bullet_passable(self, x, y):
+        """Check if the specified world coordinates are passable for bullets"""
+        tile_type = self.get_tile_at(x, y)
+
+        # Bullets can pass through grass and wood, but not objects or walls
+        return tile_type in [TILE_GRASS, TILE_WOOD]
 
     def render(self, screen, camera_offset):
         """Render the map to the screen with the specified camera offset"""
Index: src/systems/weapons.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport random\r\nimport math\r\nfrom entities.entity import Entity\r\nfrom utils.constants import (\r\n    BULLET_SIZE, BULLET_SPEED, BULLET_COLOR,\r\n    # Pistol constants\r\n    PISTOL_DAMAGE, PISTOL_SPREAD, PISTOL_MAGAZINE_SIZE, PISTOL_RELOAD_TIME, PISTOL_COOLDOWN, PISTOL_BULLET_COLOR,\r\n    # Shotgun constants\r\n    SHOTGUN_DAMAGE, SHOTGUN_PELLETS, SHOTGUN_SPREAD, SHOTGUN_MAGAZINE_SIZE, SHOTGUN_RELOAD_TIME, SHOTGUN_COOLDOWN, SHOTGUN_BULLET_COLOR,\r\n    # Assault Rifle constants\r\n    ASSAULT_RIFLE_DAMAGE, ASSAULT_RIFLE_SPREAD, ASSAULT_RIFLE_MAGAZINE_SIZE, ASSAULT_RIFLE_RELOAD_TIME, ASSAULT_RIFLE_COOLDOWN, ASSAULT_RIFLE_BULLET_COLOR,\r\n    # Sniper Rifle constants\r\n    SNIPER_RIFLE_DAMAGE, SNIPER_RIFLE_SPREAD, SNIPER_RIFLE_MAGAZINE_SIZE, SNIPER_RIFLE_RELOAD_TIME, SNIPER_RIFLE_COOLDOWN, SNIPER_RIFLE_BULLET_COLOR, SNIPER_RIFLE_BULLET_SPEED,\r\n    # Bazooka constants\r\n    BAZOOKA_DAMAGE, BAZOOKA_SPREAD, BAZOOKA_MAGAZINE_SIZE, BAZOOKA_RELOAD_TIME, BAZOOKA_COOLDOWN, BAZOOKA_BULLET_COLOR, BAZOOKA_EXPLOSION_RADIUS, BAZOOKA_BULLET_SPEED,\r\n    # General weapon settings\r\n    WEAPON_COOLDOWN\r\n)\r\n\r\nclass Weapon:\r\n    \"\"\"Base class for all weapons\"\"\"\r\n\r\n    def __init__(self, name, damage, spread, magazine_size, reload_time, cooldown):\r\n        \"\"\"Initialize the weapon\r\n\r\n        Args:\r\n            name (str): Weapon name\r\n            damage (int): Damage per bullet\r\n            spread (float): Accuracy spread in radians\r\n            magazine_size (int): Number of bullets in magazine\r\n            reload_time (float): Time to reload in seconds\r\n            cooldown (float): Time between shots in seconds\r\n        \"\"\"\r\n        self.name = name\r\n        self.damage = damage\r\n        self.spread = spread\r\n        self.magazine_size = magazine_size\r\n        self.reload_time = reload_time\r\n        self.cooldown = cooldown\r\n\r\n        # Current state\r\n        self.ammo = magazine_size\r\n        self.is_reloading = False\r\n        self.reload_timer = 0\r\n        self.cooldown_timer = 0\r\n\r\n    def update(self, dt):\r\n        \"\"\"Update weapon state\r\n\r\n        Args:\r\n            dt (float): Time delta in seconds\r\n        \"\"\"\r\n        # Update cooldown timer\r\n        if self.cooldown_timer > 0:\r\n            self.cooldown_timer -= dt\r\n\r\n        # Update reload timer\r\n        if self.is_reloading:\r\n            self.reload_timer -= dt\r\n            if self.reload_timer <= 0:\r\n                self.ammo = self.magazine_size\r\n                self.is_reloading = False\r\n\r\n    def shoot(self, x, y, angle):\r\n        \"\"\"Attempt to shoot a bullet\r\n\r\n        Args:\r\n            x (float): Starting x position\r\n            y (float): Starting y position\r\n            angle (float): Angle in radians\r\n\r\n        Returns:\r\n            Bullet or None: A new bullet if shot was successful, None otherwise\r\n        \"\"\"\r\n        # Check if weapon can shoot\r\n        if self.cooldown_timer > 0 or self.is_reloading or self.ammo <= 0:\r\n            return None\r\n\r\n        # Reset cooldown timer\r\n        self.cooldown_timer = self.cooldown\r\n\r\n        # Decrease ammo\r\n        self.ammo -= 1\r\n\r\n        # Apply spread to angle\r\n        spread_angle = angle + random.uniform(-self.spread, self.spread)\r\n\r\n        # Create a new bullet\r\n        return Bullet(x, y, spread_angle, self.damage)\r\n\r\n    def reload(self):\r\n        \"\"\"Start reloading the weapon\"\"\"\r\n        if not self.is_reloading and self.ammo < self.magazine_size:\r\n            self.is_reloading = True\r\n            self.reload_timer = self.reload_time\r\n\r\n    def can_shoot(self):\r\n        \"\"\"Check if weapon can shoot\r\n\r\n        Returns:\r\n            bool: True if weapon can shoot, False otherwise\r\n        \"\"\"\r\n        return not self.is_reloading and self.ammo > 0 and self.cooldown_timer <= 0\r\n\r\nclass Pistol(Weapon):\r\n    \"\"\"Pistol weapon - Balanced damage/fire rate\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the pistol\"\"\"\r\n        super().__init__(\r\n            name=\"Pistol\",\r\n            damage=PISTOL_DAMAGE,\r\n            spread=PISTOL_SPREAD,\r\n            magazine_size=PISTOL_MAGAZINE_SIZE,\r\n            reload_time=PISTOL_RELOAD_TIME,\r\n            cooldown=PISTOL_COOLDOWN\r\n        )\r\n\r\n    def shoot(self, x, y, angle):\r\n        \"\"\"Shoot a pistol bullet\r\n\r\n        Args:\r\n            x (float): Starting x position\r\n            y (float): Starting y position\r\n            angle (float): Angle in radians\r\n\r\n        Returns:\r\n            Bullet or None: A new bullet if shot was successful, None otherwise\r\n        \"\"\"\r\n        # Check if weapon can shoot\r\n        if self.cooldown_timer > 0 or self.is_reloading or self.ammo <= 0:\r\n            return None\r\n\r\n        # Reset cooldown timer\r\n        self.cooldown_timer = self.cooldown\r\n\r\n        # Decrease ammo\r\n        self.ammo -= 1\r\n\r\n        # Apply spread to angle\r\n        spread_angle = angle + random.uniform(-self.spread, self.spread)\r\n\r\n        # Create a new bullet\r\n        return PistolBullet(x, y, spread_angle, self.damage)\r\n\r\nclass Shotgun(Weapon):\r\n    \"\"\"Shotgun weapon - High damage at close range, slow reload\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the shotgun\"\"\"\r\n        super().__init__(\r\n            name=\"Shotgun\",\r\n            damage=SHOTGUN_DAMAGE,\r\n            spread=SHOTGUN_SPREAD,\r\n            magazine_size=SHOTGUN_MAGAZINE_SIZE,\r\n            reload_time=SHOTGUN_RELOAD_TIME,\r\n            cooldown=SHOTGUN_COOLDOWN\r\n        )\r\n\r\n    def shoot(self, x, y, angle):\r\n        \"\"\"Shoot multiple shotgun pellets\r\n\r\n        Args:\r\n            x (float): Starting x position\r\n            y (float): Starting y position\r\n            angle (float): Angle in radians\r\n\r\n        Returns:\r\n            list or None: A list of pellets if shot was successful, None otherwise\r\n        \"\"\"\r\n        # Check if weapon can shoot\r\n        if self.cooldown_timer > 0 or self.is_reloading or self.ammo <= 0:\r\n            return None\r\n\r\n        # Reset cooldown timer\r\n        self.cooldown_timer = self.cooldown\r\n\r\n        # Decrease ammo\r\n        self.ammo -= 1\r\n\r\n        # Create multiple pellets with spread\r\n        pellets = []\r\n        for _ in range(SHOTGUN_PELLETS):\r\n            # Apply spread to angle\r\n            spread_angle = angle + random.uniform(-self.spread, self.spread)\r\n\r\n            # Create a new pellet\r\n            pellet = ShotgunPellet(x, y, spread_angle, self.damage)\r\n            pellets.append(pellet)\r\n\r\n        return pellets\r\n\r\nclass AssaultRifle(Weapon):\r\n    \"\"\"Assault Rifle weapon - Rapid fire, medium damage\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the assault rifle\"\"\"\r\n        super().__init__(\r\n            name=\"Assault Rifle\",\r\n            damage=ASSAULT_RIFLE_DAMAGE,\r\n            spread=ASSAULT_RIFLE_SPREAD,\r\n            magazine_size=ASSAULT_RIFLE_MAGAZINE_SIZE,\r\n            reload_time=ASSAULT_RIFLE_RELOAD_TIME,\r\n            cooldown=ASSAULT_RIFLE_COOLDOWN\r\n        )\r\n\r\n    def shoot(self, x, y, angle):\r\n        \"\"\"Shoot an assault rifle bullet\r\n\r\n        Args:\r\n            x (float): Starting x position\r\n            y (float): Starting y position\r\n            angle (float): Angle in radians\r\n\r\n        Returns:\r\n            Bullet or None: A new bullet if shot was successful, None otherwise\r\n        \"\"\"\r\n        # Check if weapon can shoot\r\n        if self.cooldown_timer > 0 or self.is_reloading or self.ammo <= 0:\r\n            return None\r\n\r\n        # Reset cooldown timer\r\n        self.cooldown_timer = self.cooldown\r\n\r\n        # Decrease ammo\r\n        self.ammo -= 1\r\n\r\n        # Apply spread to angle\r\n        spread_angle = angle + random.uniform(-self.spread, self.spread)\r\n\r\n        # Create a new bullet\r\n        return AssaultRifleBullet(x, y, spread_angle, self.damage)\r\n\r\nclass SniperRifle(Weapon):\r\n    \"\"\"Sniper Rifle weapon - High damage, slow fire rate, high accuracy\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the sniper rifle\"\"\"\r\n        super().__init__(\r\n            name=\"Sniper Rifle\",\r\n            damage=SNIPER_RIFLE_DAMAGE,\r\n            spread=SNIPER_RIFLE_SPREAD,\r\n            magazine_size=SNIPER_RIFLE_MAGAZINE_SIZE,\r\n            reload_time=SNIPER_RIFLE_RELOAD_TIME,\r\n            cooldown=SNIPER_RIFLE_COOLDOWN\r\n        )\r\n\r\n    def shoot(self, x, y, angle):\r\n        \"\"\"Shoot a sniper rifle bullet\r\n\r\n        Args:\r\n            x (float): Starting x position\r\n            y (float): Starting y position\r\n            angle (float): Angle in radians\r\n\r\n        Returns:\r\n            Bullet or None: A new bullet if shot was successful, None otherwise\r\n        \"\"\"\r\n        # Check if weapon can shoot\r\n        if self.cooldown_timer > 0 or self.is_reloading or self.ammo <= 0:\r\n            return None\r\n\r\n        # Reset cooldown timer\r\n        self.cooldown_timer = self.cooldown\r\n\r\n        # Decrease ammo\r\n        self.ammo -= 1\r\n\r\n        # Apply spread to angle (very small spread for sniper)\r\n        spread_angle = angle + random.uniform(-self.spread, self.spread)\r\n\r\n        # Create a new bullet\r\n        return SniperRifleBullet(x, y, spread_angle, self.damage)\r\n\r\nclass Bazooka(Weapon):\r\n    \"\"\"Bazooka weapon - Explosive damage, very slow fire rate\"\"\"\r\n\r\n    def __init__(self):\r\n        \"\"\"Initialize the bazooka\"\"\"\r\n        super().__init__(\r\n            name=\"Bazooka\",\r\n            damage=BAZOOKA_DAMAGE,\r\n            spread=BAZOOKA_SPREAD,\r\n            magazine_size=BAZOOKA_MAGAZINE_SIZE,\r\n            reload_time=BAZOOKA_RELOAD_TIME,\r\n            cooldown=BAZOOKA_COOLDOWN\r\n        )\r\n\r\n    def shoot(self, x, y, angle):\r\n        \"\"\"Shoot a bazooka rocket\r\n\r\n        Args:\r\n            x (float): Starting x position\r\n            y (float): Starting y position\r\n            angle (float): Angle in radians\r\n\r\n        Returns:\r\n            Bullet or None: A new rocket if shot was successful, None otherwise\r\n        \"\"\"\r\n        # Check if weapon can shoot\r\n        if self.cooldown_timer > 0 or self.is_reloading or self.ammo <= 0:\r\n            return None\r\n\r\n        # Reset cooldown timer\r\n        self.cooldown_timer = self.cooldown\r\n\r\n        # Decrease ammo\r\n        self.ammo -= 1\r\n\r\n        # Apply spread to angle\r\n        spread_angle = angle + random.uniform(-self.spread, self.spread)\r\n\r\n        # Create a new rocket\r\n        return BazookaRocket(x, y, spread_angle, self.damage)\r\n\r\nclass Bullet(Entity):\r\n    \"\"\"Base bullet entity\"\"\"\r\n\r\n    def __init__(self, x, y, angle, damage, color=BULLET_COLOR, speed=BULLET_SPEED, size=BULLET_SIZE):\r\n        \"\"\"Initialize the bullet\r\n\r\n        Args:\r\n            x (float): Initial x position\r\n            y (float): Initial y position\r\n            angle (float): Movement angle in radians\r\n            damage (int): Damage amount\r\n            color (tuple): RGB color tuple\r\n            speed (float): Bullet speed in pixels per second\r\n            size (int): Bullet size in pixels\r\n        \"\"\"\r\n        super().__init__(x, y, size, size, color)\r\n        self.angle = angle\r\n        self.damage = damage\r\n        self.speed = speed\r\n        self.distance_traveled = 0\r\n        self.max_distance = 1000  # Maximum travel distance before bullet disappears\r\n        self.is_explosive = False  # Whether the bullet explodes on impact\r\n        self.explosion_radius = 0  # Explosion radius in pixels\r\n\r\n    def update(self, dt, map_generator=None):\r\n        \"\"\"Update bullet position\r\n\r\n        Args:\r\n            dt (float): Time delta in seconds\r\n            map_generator (MapGenerator, optional): Reference to the map generator\r\n        \"\"\"\r\n        # Calculate movement vector\r\n        dx = math.cos(self.angle) * self.speed * dt\r\n        dy = math.sin(self.angle) * self.speed * dt\r\n\r\n        # Update position\r\n        self.x += dx\r\n        self.y += dy\r\n\r\n        # Update distance traveled\r\n        self.distance_traveled += math.sqrt(dx * dx + dy * dy)\r\n\r\n        # Check for collision with map if map_generator is provided\r\n        if map_generator and not map_generator.is_walkable(self.x, self.y):\r\n            self.distance_traveled = self.max_distance  # Mark for removal\r\n\r\n        # Call parent update to update rect\r\n        super().update(dt)\r\n\r\n    def is_expired(self):\r\n        \"\"\"Check if bullet has expired\r\n\r\n        Returns:\r\n            bool: True if bullet has traveled its maximum distance, False otherwise\r\n        \"\"\"\r\n        return self.distance_traveled >= self.max_distance\r\n\r\n    def render(self, screen, camera_offset=(0, 0)):\r\n        \"\"\"Render the bullet as a small circle\r\n\r\n        Args:\r\n            screen (pygame.Surface): Screen to render on\r\n            camera_offset (tuple): Camera offset (x, y)\r\n        \"\"\"\r\n        # Calculate center position\r\n        center_x = self.rect.x + self.width // 2 - camera_offset[0]\r\n        center_y = self.rect.y + self.height // 2 - camera_offset[1]\r\n\r\n        # Draw bullet as a small circle\r\n        pygame.draw.circle(screen, self.color, (center_x, center_y), self.width // 2)\r\n\r\n    def explode(self):\r\n        \"\"\"Handle explosion for explosive bullets\r\n\r\n        Returns:\r\n            list: List of entities hit by the explosion\r\n        \"\"\"\r\n        # Base implementation does nothing\r\n        return []\r\n\r\nclass PistolBullet(Bullet):\r\n    \"\"\"Pistol bullet - Standard bullet with medium speed and damage\"\"\"\r\n\r\n    def __init__(self, x, y, angle, damage):\r\n        \"\"\"Initialize the pistol bullet\"\"\"\r\n        super().__init__(\r\n            x=x,\r\n            y=y,\r\n            angle=angle,\r\n            damage=damage,\r\n            color=PISTOL_BULLET_COLOR,\r\n            speed=BULLET_SPEED,\r\n            size=BULLET_SIZE\r\n        )\r\n\r\nclass ShotgunPellet(Bullet):\r\n    \"\"\"Shotgun pellet - Small, fast bullet with low damage\"\"\"\r\n\r\n    def __init__(self, x, y, angle, damage):\r\n        \"\"\"Initialize the shotgun pellet\"\"\"\r\n        super().__init__(\r\n            x=x,\r\n            y=y,\r\n            angle=angle,\r\n            damage=damage,\r\n            color=SHOTGUN_BULLET_COLOR,\r\n            speed=BULLET_SPEED * 1.2,  # Slightly faster\r\n            size=BULLET_SIZE - 2  # Smaller\r\n        )\r\n        self.max_distance = 500  # Shorter range\r\n\r\nclass AssaultRifleBullet(Bullet):\r\n    \"\"\"Assault rifle bullet - Fast bullet with medium damage\"\"\"\r\n\r\n    def __init__(self, x, y, angle, damage):\r\n        \"\"\"Initialize the assault rifle bullet\"\"\"\r\n        super().__init__(\r\n            x=x,\r\n            y=y,\r\n            angle=angle,\r\n            damage=damage,\r\n            color=ASSAULT_RIFLE_BULLET_COLOR,\r\n            speed=BULLET_SPEED * 1.1,  # Slightly faster\r\n            size=BULLET_SIZE\r\n        )\r\n\r\nclass SniperRifleBullet(Bullet):\r\n    \"\"\"Sniper rifle bullet - Very fast bullet with high damage\"\"\"\r\n\r\n    def __init__(self, x, y, angle, damage):\r\n        \"\"\"Initialize the sniper rifle bullet\"\"\"\r\n        super().__init__(\r\n            x=x,\r\n            y=y,\r\n            angle=angle,\r\n            damage=damage,\r\n            color=SNIPER_RIFLE_BULLET_COLOR,\r\n            speed=SNIPER_RIFLE_BULLET_SPEED,  # Much faster\r\n            size=BULLET_SIZE + 2  # Slightly larger\r\n        )\r\n        self.max_distance = 2000  # Longer range\r\n\r\nclass BazookaRocket(Bullet):\r\n    \"\"\"Bazooka rocket - Slow bullet with explosive damage\"\"\"\r\n\r\n    def __init__(self, x, y, angle, damage):\r\n        \"\"\"Initialize the bazooka rocket\"\"\"\r\n        super().__init__(\r\n            x=x,\r\n            y=y,\r\n            angle=angle,\r\n            damage=damage,\r\n            color=BAZOOKA_BULLET_COLOR,\r\n            speed=BAZOOKA_BULLET_SPEED,  # Slower\r\n            size=BULLET_SIZE * 2  # Much larger\r\n        )\r\n        self.is_explosive = True\r\n        self.explosion_radius = BAZOOKA_EXPLOSION_RADIUS\r\n\r\n    def render(self, screen, camera_offset=(0, 0)):\r\n        \"\"\"Render the rocket as a larger circle with a trail\r\n\r\n        Args:\r\n            screen (pygame.Surface): Screen to render on\r\n            camera_offset (tuple): Camera offset (x, y)\r\n        \"\"\"\r\n        # Calculate center position\r\n        center_x = self.rect.x + self.width // 2 - camera_offset[0]\r\n        center_y = self.rect.y + self.height // 2 - camera_offset[1]\r\n\r\n        # Draw rocket as a larger circle\r\n        pygame.draw.circle(screen, self.color, (center_x, center_y), self.width // 2)\r\n\r\n        # Draw a trail behind the rocket\r\n        trail_length = 20\r\n        trail_end_x = center_x - math.cos(self.angle) * trail_length\r\n        trail_end_y = center_y - math.sin(self.angle) * trail_length\r\n\r\n        # Draw trail as a line\r\n        pygame.draw.line(screen, (255, 165, 0), (center_x, center_y), (trail_end_x, trail_end_y), 3)\r\n\r\n    def explode(self):\r\n        \"\"\"Handle explosion for bazooka rocket\r\n\r\n        Returns:\r\n            list: List of entities hit by the explosion\r\n        \"\"\"\r\n        # In a more complete implementation, this would check for entities within\r\n        # the explosion radius and return them for damage calculation\r\n\r\n        # For now, just mark the bullet as expired\r\n        self.distance_traveled = self.max_distance\r\n        return []\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/systems/weapons.py b/src/systems/weapons.py
--- a/src/systems/weapons.py	(revision 4bce95d1d51963b52aa711b95eef7c6fa02c202d)
+++ b/src/systems/weapons.py	(date 1749912194001)
@@ -357,7 +357,7 @@
         self.distance_traveled += math.sqrt(dx * dx + dy * dy)
 
         # Check for collision with map if map_generator is provided
-        if map_generator and not map_generator.is_walkable(self.x, self.y):
+        if map_generator and not map_generator.is_bullet_passable(self.x, self.y):
             self.distance_traveled = self.max_distance  # Mark for removal
 
         # Call parent update to update rect
